<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>趣味思维导图</title>
  <!-- 引入vis-network库 -->
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <!-- 引入JSZip库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
  <!-- 引入FileSaver库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    /* 引入Comic Neue字体 */
    @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap');

    /* 基础样式设置 */
    body,
    html {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Comic Neue', cursive;
      background-color: #FFF5E6;
      position: relative;
    }

    /* 思维导图容器样式 */
    #mindmap {
      width: 100%;
      height: 100%;
      background-color: #FFF5E6;
      /* 创建点状背景 */
      background-image:
              radial-gradient(#FFD699 2px, transparent 2px),
              radial-gradient(#FFB366 2px, transparent 2px);
      background-size: 40px 40px;
      background-position: 0 0, 20px 20px;
    }

    /* 悬浮操作说明容器样式 */
    #operation-container {
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
      border: 2px solid #FF9933;
      overflow: auto;
      max-width: 90%;
      max-height: 90%;
      z-index: 1000;
      box-sizing: border-box;
      resize: none;
    }

    /* 关闭按钮样式 */
    #close-operation {
      position: absolute;
      top: 5px;
      right: 10px;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #8B4513;
    }

    /* 展开按钮样式 */
    #show-operation-button {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: #FF9933;
      border: none;
      border-radius: 5px;
      padding: 8px 12px;
      font-size: 14px;
      color: #FFFFFF;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      display: none;
      z-index: 1000;
    }

    /* 操作说明项目样式 */
    .instruction-item {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }

    /* 操作图标样式 */
    .instruction-icon {
      display: inline-block;
      width: 30px;
      height: 30px;
      text-align: center;
      line-height: 30px;
      border-radius: 50%;
      margin-right: 10px;
      font-size: 18px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      flex-shrink: 0;
    }

    /* 不同操作的图标颜色 */
    .add-node-icon {
      background-color: #98FB98;
      color: #006400;
    }

    .add-child-icon {
      background-color: #87CEFA;
      color: #00008B;
    }

    .edit-node-icon {
      background-color: #FFA07A;
      color: #8B0000;
    }

    .delete-node-icon {
      background-color: #FFCC99;
      color: #8B4513;
    }

    .undo-icon {
      background-color: #D3D3D3;
      color: #000000;
    }

    .redo-icon {
      background-color: #D3D3D3;
      color: #000000;
    }

    /* 操作按钮样式 */
    .operation-button {
      display: flex;
      align-items: center;
      cursor: pointer;
      user-select: none;
    }

    /* 概览按钮样式 */
    #overview-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #FF9933;
      border: none;
      outline: none;
      cursor: pointer;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    /* 概览按钮悬停和点击效果 */
    #overview-button:hover {
      transform: scale(1.1);
    }

    #overview-button:active {
      transform: scale(0.9);
    }

    /* 概览按钮图标样式 */
    #overview-button svg {
      width: 30px;
      height: 30px;
      fill: #8B4513;
    }

    /* 新节点弹出动画 */
    @keyframes bounceIn {
      0% {
        transform: scale(0.1);
        opacity: 0;
      }

      60% {
        transform: scale(1.2);
        opacity: 1;
      }

      100% {
        transform: scale(1);
      }
    }

    .new-node {
      animation: bounceIn 0.6s;
    }

    /* 滚动条样式优化 */
    #operation-container::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    #operation-container::-webkit-scrollbar-thumb {
      background-color: #FF9933;
      border-radius: 4px;
    }

    #operation-container::-webkit-scrollbar-track {
      background-color: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
    }

    /* Resize Handle 样式 */
    .resize-handle {
      position: absolute;
      width: 15px;
      height: 15px;
      background-color: #FF9933;
      border: 2px solid #8B4513;
      border-radius: 50%;
      cursor: se-resize;
      z-index: 1001;
      display: none; /* 初始隐藏 */
    }

    /* 图片容器样式 */
    .image-container {
      position: relative;
      width: 100%;
      height: 100%;
      resize: both;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .image-container img {
      width: 100%;
      height: 100%;
      object-fit: contain; /* 保持等比例适应 */
    }

    /* 导出Word按钮样式 */
    #export-word-button {
      position: fixed;
      bottom: 100px;
      right: 20px;
      background-color: #4CAF50;
      border: none;
      border-radius: 5px;
      padding: 10px 15px;
      font-size: 14px;
      color: #FFFFFF;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }

    #export-word-button:hover {
      background-color: #45a049;
    }

    #export-word-button:active {
      background-color: #39843c;
    }
  </style>
</head>

<body>
<!-- 操作说明悬浮容器 -->
<div id="operation-container" style="display: none;">
  <!-- 关闭按钮 -->
  <button id="close-operation" title="关闭操作说明">&times;</button>
  <div class="operation-instructions">
    <div class="instruction-item">
      <span class="instruction-icon add-node-icon">+</span>
      <span>Enter: 添加同级节点</span>
    </div>
    <div class="instruction-item">
      <span class="instruction-icon add-child-icon">⇥</span>
      <span>Tab: 添加子节点</span>
    </div>
    <div class="instruction-item">
      <span class="instruction-icon edit-node-icon">✎</span>
      <span>Double left-click: 编辑节点</span>
    </div>
    <div class="instruction-item">
      <span class="instruction-icon delete-node-icon">✖</span>
      <span>Delete/Backspace: 删除节点</span>
    </div>
    <div class="instruction-item operation-button" id="undo-button" title="撤销">
      <span class="instruction-icon undo-icon">↶</span>
      <span style="margin-left: 10px;">Ctrl+Z: 撤销</span>
    </div>
    <div class="instruction-item operation-button" id="redo-button" title="重做">
      <span class="instruction-icon redo-icon">↷</span>
      <span style="margin-left: 10px;">Ctrl+Y: 重做</span>
    </div>
  </div>
</div>

<!-- 展开操作说明按钮 -->
<button id="show-operation-button" style="display: block;" title="显示操作说明">显示操作说明</button>

<!-- 思维导图容器 -->
<div id="mindmap"></div>

<!-- 概览按钮 -->
<button id="overview-button" title="重新调整视图">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path
            d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3h-6zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3v6zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6h6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6v-6z" />
  </svg>
</button>

<!-- 导出Word按钮 -->
<button id="export-word-button" title="导出为Word文档">导出为Word</button>

<!-- Resize Handle -->
<div id="resize-handle" class="resize-handle"></div>

<script>
  // 获取元素
  const operationContainer = document.getElementById('operation-container');
  const closeOperationButton = document.getElementById('close-operation');
  const showOperationButton = document.getElementById('show-operation-button');
  const overviewButton = document.getElementById('overview-button');
  const undoButton = document.getElementById('undo-button');
  const redoButton = document.getElementById('redo-button');
  const resizeHandle = document.getElementById('resize-handle');

  // 控制最后被编辑节点的ID
  let lastModifiedNodeId = null;

  // 控制是否正在编辑节点
  let isEditingNode = false;

  // 控制是否正在执行撤销/重做
  let isExecutingUndoRedo = false;

  // 关闭操作说明容器
  closeOperationButton.addEventListener('click', () => {
    operationContainer.style.display = 'none';
    showOperationButton.style.display = 'block';
  });

  // 展开操作说明容器
  showOperationButton.addEventListener('click', () => {
    operationContainer.style.display = 'block';
    showOperationButton.style.display = 'none';
  });

  // 初始化节点数据
  const nodes = new vis.DataSet([
    {
      id: 1,
      label: '主题',
      shape: 'box',
      font: { multi: true },
      fixed: { x: true, y: true },
      size: 30 // 设置节点初始大小
    }
  ]);

  // 初始化边数据
  const edges = new vis.DataSet([]);

  // 获取思维导图容器
  const container = document.getElementById('mindmap');
  const data = { nodes, edges };

  // 配置网络图选项
  const options = {
    layout: { hierarchical: false },
    nodes: {
      shape: 'box',
      widthConstraint: { minimum: 100, maximum: 250 },
      font: { size: 20, multi: true, face: 'Comic Neue' },
      borderWidth: 3,
      shadow: true,
      color: {
        border: '#FF9933',
        background: '#FFFACD',
        highlight: { border: '#FF8000', background: '#FFE699' },
        hover: { border: '#FF8000', background: '#FFE699' }
      },
      shapeProperties: {
        borderRadius: 10
      },
      fixed: { x: true, y: true }
    },
    edges: {
      arrows: 'to',
      width: 3,
      color: '#FF9933',
      smooth: { type: 'cubicBezier', forceDirection: 'horizontal', roundness: 0.5 }
    },
    physics: { enabled: false },
    interaction: {
      dragNodes: true,
      dragView: true,
      zoomView: true,
      hover: true,
      selectable: true,
      selectConnectedEdges: false,
      multiselect: false,
      tooltipDelay: 300,
      hideEdgesOnDrag: false,
      hideNodesOnDrag: false
    },
    manipulation: { enabled: false }
  };

  // 创建网络图实例
  const network = new vis.Network(container, data, options);

  // 历史记录栈
  const undoStack = [];
  const redoStack = [];

  // 函数：深拷贝对象
  function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // 函数：记录当前状态到undoStack
  function saveStateToUndo(actionNodeId = null) {
    if (isExecutingUndoRedo) return;
    const currentState = {
      nodes: deepCopy(nodes.get()), // 保存所有节点属性
      edges: deepCopy(edges.get()),
      lastModifiedNodeId: actionNodeId
    };
    undoStack.push(currentState);
    // 限制历史记录栈的大小（可选）
    if (undoStack.length > 100) {
      undoStack.shift();
    }
    // 清空redoStack
    redoStack.length = 0;
  }

  // 函数：恢复到指定状态
  function restoreState(state) {
    isExecutingUndoRedo = true;
    nodes.clear();
    edges.clear();
    nodes.add(state.nodes);
    edges.add(state.edges);
    lastModifiedNodeId = state.lastModifiedNodeId;
    applyCustomLayout();
    isExecutingUndoRedo = false;
    // 自动选中上一个被编辑的节点
    if (lastModifiedNodeId !== null) {
      network.selectNodes([lastModifiedNodeId]);
    }
  }

  // 概览按钮点击事件
  overviewButton.addEventListener('click', () => {
    network.fit({
      animation: {
        duration: 1000,
        easingFunction: 'easeInOutQuad'
      }
    });
  });

  // 撤销按钮点击事件
  undoButton.addEventListener('click', () => {
    if (undoStack.length === 0) return;
    const currentState = {
      nodes: deepCopy(nodes.get()),
      edges: deepCopy(edges.get()),
      lastModifiedNodeId: lastModifiedNodeId
    };
    redoStack.push(currentState);
    const previousState = undoStack.pop();
    restoreState(previousState);
  });

  // 重做按钮点击事件
  redoButton.addEventListener('click', () => {
    if (redoStack.length === 0) return;
    const currentState = {
      nodes: deepCopy(nodes.get()),
      edges: deepCopy(edges.get()),
      lastModifiedNodeId: lastModifiedNodeId
    };
    undoStack.push(currentState);
    const nextState = redoStack.pop();
    restoreState(nextState);
  });

  // 键盘快捷键事件处理
  document.addEventListener('keydown', function (event) {
    // Ctrl+Z for Undo
    if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'z') {
      event.preventDefault();
      undoButton.click();
      return;
    }
    // Ctrl+Y for Redo
    if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'y') {
      event.preventDefault();
      redoButton.click();
      return;
    }
    const tag = event.target.tagName;
    if (isEditingNode || tag === 'INPUT' || tag === 'TEXTAREA') {
      return;
    }
    const selectedNodes = network.getSelectedNodes();
    if (selectedNodes.length === 1) {
      const selectedNode = selectedNodes[0];
      const node = nodes.get(selectedNode);
      if (!node) return; // 防止node为null
      // 检查是否是根节点（假设根节点ID为1）
      const isRootNode = node.id === 1 || edges.get().filter(edge => edge.to === node.id).length === 0;
      if (event.key === 'Enter') {
        // 添加同级节点
        event.preventDefault();
        saveStateToUndo(lastModifiedNodeId);
        const connectedEdges = network.getConnectedEdges(selectedNode);
        const parentEdge = edges.get(connectedEdges).find(edge => edge.to === selectedNode);
        const newNodeId = getNextNodeId();
        addNodeWithAnimation(newNodeId, `新节点${newNodeId}`, parentEdge ? parentEdge.from : selectedNode);
        network.selectNodes([newNodeId]);
        lastModifiedNodeId = newNodeId; // 更新最后修改节点ID
      } else if (event.key === 'Tab') {
        // 添加子节点
        event.preventDefault();
        saveStateToUndo(lastModifiedNodeId);
        const newNodeId = getNextNodeId();
        addNodeWithAnimation(newNodeId, `新节点${newNodeId}`, selectedNode);
        network.selectNodes([newNodeId]);
        lastModifiedNodeId = newNodeId; // 更新最后修改节点ID
      } else if ((event.key === 'Backspace' || event.key === 'Delete')) {
        event.preventDefault();
        if (node.shape === 'image') {
          // 仅移除图片，保留节点
          saveStateToUndo(selectedNode);
          nodes.update({
            id: selectedNode,
            shape: 'box',
            image: undefined // 移除图片
          });
          lastModifiedNodeId = selectedNode; // 更新最后修改节点ID
        } else {
          // 不允许删除根节点
          if (isRootNode) {
            alert("不允许删除根节点！");
            return;
          }
          // 删除节点及其后代
          saveStateToUndo(lastModifiedNodeId);
          const previousNodeId = getPreviousNodeId(selectedNode);
          deleteNodeAndDescendants(selectedNode);
          setTimeout(() => {
            applyCustomLayout();
            if (previousNodeId) {
              network.selectNodes([previousNodeId]);
              lastModifiedNodeId = previousNodeId; // 更新最后修改节点ID
            }
          }, 100);
        }
      }
    }
  });

  // 双击节点编辑事件
  network.on('doubleClick', function (params) {
    if (params.nodes.length === 1) {
      const nodeId = params.nodes[0];
      const node = nodes.get(nodeId);
      if (!node) return; // 防止node为null
      saveStateToUndo(lastModifiedNodeId);
      isEditingNode = true;
      const position = network.getPositions([nodeId])[nodeId];
      if (!position) return; // 防止position为null
      const domPos = network.canvasToDOM(position);
      // 创建编辑输入框
      const input = document.createElement('textarea');
      // 获取节点的文本内容
      let labelText = node.label || '';
      input.value = labelText;
      input.style.position = 'absolute';
      input.style.left = `${domPos.x - 140}px`;
      input.style.top = `${domPos.y - 35}px`;
      input.style.zIndex = 1001; /* 高于操作说明容器 */
      input.style.width = '280px';
      input.style.height = '70px';
      input.style.fontSize = '22px';
      input.style.fontFamily = 'Comic Neue, cursive';
      input.style.border = '3px solid #FF9933';
      input.style.borderRadius = '10px';
      input.style.padding = '10px';
      input.style.boxShadow = '0 0 15px rgba(0, 0, 0, 0.1)';
      input.style.backgroundColor = '#FFFACD';
      document.body.appendChild(input);
      input.focus();
      input.select();
      // 处理输入变化
      const handleInputChange = () => {
        const newLabelText = input.value.trim();
        // 更新节点的文本数据
        nodes.update({
          id: nodeId,
          label: newLabelText
        });
        lastModifiedNodeId = nodeId; // 更新最后修改节点ID

        if (document.body.contains(input)) {
          document.body.removeChild(input);
        }
        isEditingNode = false;
      };
      // 输入框键盘事件
      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleInputChange();
        }
        event.stopPropagation();
      });
      // 输入框失焦事件
      input.addEventListener('blur', handleInputChange);
    }
  });

  // 添加粘贴事件监听
  document.addEventListener('paste', function (event) {
    if (isEditingNode) return; // 编辑模式下不处理
    const items = event.clipboardData.items;
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf("image") !== -1) {
        // 有图片
        const blob = items[i].getAsFile();
        const reader = new FileReader();
        reader.onload = function (event) {
          const dataUrl = event.target.result;
          const selectedNodes = network.getSelectedNodes();
          if (selectedNodes.length === 1) {
            const nodeId = selectedNodes[0];
            saveStateToUndo(nodeId);
            // 更新节点形状和图像
            nodes.update({
              id: nodeId,
              shape: 'image',
              image: dataUrl,
              label: nodes.get(nodeId).label || '',
              size: 30 // 初始大小
            });
            lastModifiedNodeId = nodeId; // 更新最后修改节点ID
          }
        };
        reader.readAsDataURL(blob);
        event.preventDefault();
        return;
      }
    }
  });

  // 显示Resize Handle
  network.on('selectNode', function (params) {
    if (params.nodes.length === 1) {
      const nodeId = params.nodes[0];
      const node = nodes.get(nodeId);
      if (node && node.shape === 'image') {
        showResizeHandle(nodeId, node);
      } else {
        hideResizeHandle();
      }
    } else {
      hideResizeHandle();
    }
  });

  // 隐藏Resize Handle
  network.on('deselectNode', function (params) {
    hideResizeHandle();
  });

  // 显示Resize Handle函数
  function showResizeHandle(nodeId, node) {
    if (!node) return; // 防止node为null
    const positions = network.getPositions([nodeId]);
    const position = positions[nodeId];
    if (!position) return; // 防止position为null
    const domCoords = network.canvasToDOM(position);
    // 设置Resize Handle的位置，位于节点的右下角
    resizeHandle.style.left = `${domCoords.x + getNodeWidth(node) - 7.5}px`;
    resizeHandle.style.top = `${domCoords.y + getNodeHeight(node) - 7.5}px`;
    resizeHandle.style.display = 'block';
  }

  // 隐藏Resize Handle函数
  function hideResizeHandle() {
    resizeHandle.style.display = 'none';
    resizingNodeId = null;
  }

  // 获取节点的宽度
  function getNodeWidth(node) {
    // 根据节点形状和大小计算宽度
    if (node.shape === 'image') {
      return node.size * 2; // 修改为 size * 2 以符合vis-network的size定义
    }
    return node.size * 2; // 对于其他形状也使用 size * 2
  }

  // 获取节点的高度
  function getNodeHeight(node) {
    // 根据节点形状和大小计算高度
    if (node.shape === 'image') {
      return node.size * 2; // 修改为 size * 2 以符合vis-network的size定义
    }
    return node.size * 2; // 对于其他形状也使用 size * 2
  }

  // 初始 Resize 相关变量
  let isResizing = false;
  let initialMouseX, initialMouseY;
  let initialSize;
  let resizingNodeId;

  // 实现Resize Handle拖拽功能
  resizeHandle.addEventListener('mousedown', function (event) {
    event.preventDefault();
    isResizing = true;
    initialMouseX = event.clientX;
    initialMouseY = event.clientY;
    const selectedNodes = network.getSelectedNodes();
    if (selectedNodes.length === 1) {
      resizingNodeId = selectedNodes[0];
      const node = nodes.get(resizingNodeId);
      if (node) {
        initialSize = node.size;
      }
    }
  });

  document.addEventListener('mousemove', function (event) {
    if (isResizing && resizingNodeId !== null) {
      const deltaX = event.clientX - initialMouseX;
      const deltaY = event.clientY - initialMouseY;
      const delta = Math.max(deltaX, deltaY);
      const newSize = Math.max(10, initialSize + delta / 2); // 提高灵敏度，从 /5 改为 /2
      const node = nodes.get(resizingNodeId);
      if (node) {
        nodes.update({
          id: resizingNodeId,
          size: newSize
        });
        // 实时更新Resize Handle位置
        const positions = network.getPositions([resizingNodeId]);
        const position = positions[resizingNodeId];
        if (position) {
          const domCoords = network.canvasToDOM(position);
          resizeHandle.style.left = `${domCoords.x + getNodeWidth(node) - 7.5}px`;
          resizeHandle.style.top = `${domCoords.y + getNodeHeight(node) - 7.5}px`;
        }
      }
    }
  });

  document.addEventListener('mouseup', function (event) {
    if (isResizing && resizingNodeId !== null) {
      isResizing = false;
      saveStateToUndo(resizingNodeId);
      applyCustomLayout();
      resizingNodeId = null;
    }
  });

  // 更新Resize Handle的位置在每次渲染后
  network.on('afterDrawing', function () {
    const selectedNodes = network.getSelectedNodes();
    if (selectedNodes.length === 1) {
      const nodeId = selectedNodes[0];
      const node = nodes.get(nodeId);
      if (node && node.shape === 'image') {
        const positions = network.getPositions([nodeId]);
        const position = positions[nodeId];
        if (position) {
          const domCoords = network.canvasToDOM(position);
          resizeHandle.style.left = `${domCoords.x + getNodeWidth(node) - 7.5}px`;
          resizeHandle.style.top = `${domCoords.y + getNodeHeight(node) - 7.5}px`;
        }
      }
    }
  });

  // 节点拖动开始事件
  network.on("dragStart", function (params) {
    if (params.nodes.length === 1) {
      network.setOptions({ physics: false });
    }
    hideResizeHandle();
  });

  // 节点拖动结束事件
  network.on("dragEnd", function (params) {
    if (params.nodes.length === 1) {
      saveStateToUndo(lastModifiedNodeId);
      applyCustomLayout();
    }
  });

  // 节点变化事件
  nodes.on(['add', 'remove', 'update'], function (event, properties, senderId) {
    if (!isExecutingUndoRedo) {
      applyCustomLayout();
    }
  });

  // 边变化事件
  edges.on(['add', 'remove', 'update'], function (event, properties, senderId) {
    if (!isExecutingUndoRedo) {
      applyCustomLayout();
    }
  });

  // 函数：获取下一个节点ID
  function getNextNodeId() {
    const existingIds = nodes.getIds();
    return Math.max(...existingIds) + 1;
  }

  // 函数：应用自定义布局
  function applyCustomLayout() {
    if (isExecutingUndoRedo) {
      // 避免在撤销/重做时重新应用布局
      return;
    }
    const tree = buildTree();
    const roots = findRoots(tree);
    const nodeSeparation = 150;
    const levelSeparation = 220;
    const startX = 50;
    const startY = container.clientHeight / 2;
    let currentY = startY;
    roots.forEach(root => {
      currentY = layoutNode(root, 0, startX, currentY, nodeSeparation, levelSeparation);
    });
    nodes.forEach(node => {
      if (tree[node.id]) { // 确保tree中有该节点的数据
        nodes.update({
          id: node.id,
          x: tree[node.id].x,
          y: tree[node.id].y
        });
      }
    });
    network.fit({
      animation: {
        duration: 1000,
        easingFunction: 'easeInOutQuad'
      }
    });
  }

  // 函数：构建树结构
  function buildTree() {
    const tree = {};
    nodes.forEach(node => {
      tree[node.id] = { ...node, children: [] };
    });
    edges.forEach(edge => {
      if (tree[edge.from] && tree[edge.to]) {
        tree[edge.from].children.push(tree[edge.to]);
      }
    });
    return tree;
  }

  // 函数：查找根节点
  function findRoots(tree) {
    return Object.values(tree).filter(node => !edges.get().some(edge => edge.to === node.id));
  }

  // 函数：布局节点
  function layoutNode(node, depth, xOffset, yOffset, nodeSeparation, levelSeparation) {
    node.x = xOffset + depth * levelSeparation;
    let numChildren = node.children.length;
    if (numChildren === 0) {
      node.y = yOffset;
      return yOffset + nodeSeparation;
    }
    let currentY = yOffset - (numChildren - 1) * nodeSeparation / 2;
    node.children.forEach(child => {
      currentY = layoutNode(child, depth + 1, xOffset, currentY, nodeSeparation, levelSeparation);
    });
    const firstChild = node.children[0];
    const lastChild = node.children[node.children.length - 1];
    node.y = (firstChild.y + lastChild.y) / 2;
    return currentY;
  }

  // 函数：删除节点及其后代
  function deleteNodeAndDescendants(nodeId) {
    const descendants = getDescendants(nodeId);
    nodes.remove([nodeId, ...descendants]);
    edges.remove(edges.get().filter(edge => edge.from === nodeId || edge.to === nodeId || descendants.includes(edge.from) || descendants.includes(edge.to)));
  }

  // 函数：获取节点的后代
  function getDescendants(nodeId) {
    const descendants = [];
    const childEdges = edges.get().filter(edge => edge.from === nodeId);
    childEdges.forEach(edge => {
      descendants.push(edge.to);
      descendants.push(...getDescendants(edge.to));
    });
    return descendants;
  }

  // 函数：添加带动画的新节点
  function addNodeWithAnimation(newNodeId, label, parentNodeId) {
    const parentNode = nodes.get(parentNodeId);
    const parentPos = parentNode ? network.getPositions([parentNodeId])[parentNodeId] : null;
    const initialX = parentPos ? parentPos.x + 50 : 50;
    const initialY = parentPos ? parentPos.y : container.clientHeight / 2;
    nodes.add({
      id: newNodeId,
      label: label,
      shape: 'box', // 确保设置shape
      x: initialX,
      y: initialY,
      fixed: { x: false, y: false },
      color: { background: 'rgba(255, 255, 255, 0)', border: 'rgba(0, 0, 0, 0)' },
      font: { color: 'rgba(0, 0, 0, 0)' },
      size: 30
    });
    edges.add({
      from: parentNodeId,
      to: newNodeId
    });
    setTimeout(() => {
      nodes.update({
        id: newNodeId,
        color: { background: '#FFFACD', border: '#FF9933' },
        font: { color: '#000000' },
        className: 'new-node'
      });
    }, 50);
    setTimeout(() => {
      nodes.update({
        id: newNodeId,
        className: ''
      });
    }, 650);
    setTimeout(() => {
      applyCustomLayout();
    }, 100);
  }

  // 函数：获取前一个节点ID
  function getPreviousNodeId(currentNodeId) {
    const allNodes = nodes.get({
      returnType: "object",
      fields: ['id']
    });
    const allNodeArray = Object.values(allNodes).sort((a, b) => a.id - b.id);
    const currentIndex = allNodeArray.findIndex(node => node.id === currentNodeId);
    if (currentIndex > 0) {
      return allNodeArray[currentIndex - 1].id;
    }
    return null;
  }

  // 初始应用布局
  applyCustomLayout();

  // 窗口大小变化时重新应用布局
  window.addEventListener('resize', applyCustomLayout);

  // ------------------- 导出为Word功能开始 -------------------

  // 获取导出按钮
  const exportWordButton = document.getElementById('export-word-button');

  // 绑定点击事件
  exportWordButton.addEventListener('click', exportToWord);

  // 导出函数
  function exportToWord() {
    const zip = new JSZip();

    // 创建 required Word结构文件
    zip.file('[Content_Types].xml', generateContentTypes());
    zip.folder('_rels').file('.rels', generateRels());
    zip.folder('word').file('document.xml', generateDocumentXML());
    zip.folder('word').file('_rels/document.xml.rels', generateDocumentRels());
    zip.folder('word').file('styles.xml', generateStylesXML());

    // 处理图片
    const images = gatherImages();
    const mediaFolder = zip.folder('word/media');
    let imageIndex = 1;
    const imageRelMap = {}; // nodeId -> relationship id
    for (const [nodeId, dataUrl] of Object.entries(images)) {
      const base64Data = dataUrl.split(',')[1];
      const mimeType = dataUrl.split(';')[0].split('/')[1];
      const extension = mimeType === 'jpeg' ? 'jpg' : mimeType; // 支持jpeg和png
      const imageName = `image${imageIndex}.${extension}`;
      mediaFolder.file(imageName, base64ToArrayBuffer(base64Data), { base64: true });
      imageRelMap[nodeId] = `rId${imageIndex + 1}`; // rId1已用于styles.xml
      imageIndex++;
    }

    // 生成 word/_rels/document.xml.rels 文件，添加图片关系
    zip.folder('word/_rels').file('document.xml.rels', generateDocumentRelsContent(imageRelMap));

    // 生成最终的Word文档
    zip.generateAsync({ type: "blob" })
            .then(function (content) {
              saveAs(content, "思维导图.docx");
            })
            .catch(function (err) {
              console.error("Error generating Word document:", err);
              alert("导出过程中发生错误，请检查控制台以获取更多信息。");
            });
  }

  // 辅助函数：生成 [Content_Types].xml
  function generateContentTypes() {
    return `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Default Extension="png" ContentType="image/png"/>
  <Default Extension="jpeg" ContentType="image/jpeg"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`;
  }

  // 辅助函数：生成 _rels/.rels
  function generateRels() {
    return `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
</Relationships>`;
  }

  // 辅助函数：生成 word/styles.xml
  function generateStylesXML() {
    return `<?xml version="1.0" encoding="UTF-8"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:basedOn w:val=""/>
    <w:next w:val="Normal"/>
    <w:rsidR w:val="00000000"/>
    <w:pPr>
      <w:spacing w:after="200"/>
    </w:pPr>
    <w:rPr>
      <w:rFonts w:ascii="Arial" w:hAnsi="Arial" w:cs="Arial"/>
      <w:color w:val="000000"/>
      <w:sz w:val="24"/>
    </w:rPr>
  </w:style>
</w:styles>`;
  }

  // 辅助函数：生成 word/document.xml
  function generateDocumentXML() {
    // 构建树结构
    const tree = buildTree();
    const roots = findRoots(tree);

    // 递归生成段落
    let bodyContent = '';
    roots.forEach(root => {
      bodyContent += generateParagraph(root, 0, tree);
    });

    return `<?xml version="1.0" encoding="UTF-8"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
           xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <w:body>
    ${bodyContent}
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"
              w:header="720" w:footer="720" w:gutter="0"/>
    </w:sectPr>
  </w:body>
</w:document>`;
  }

  // 辅助函数：生成段落，包括图片
  function generateParagraph(node, level, tree) {
    let indent = level * 720; // 每级缩进720 (0.5 英寸)
    let paragraph = `
    <w:p>
      <w:pPr>
        <w:ind w:left="${indent}"/>
      </w:pPr>
      <w:r>
        <w:t>${escapeXML(node.label)}</w:t>
      </w:r>
    </w:p>`;

    // 检查是否有图片
    if (node.shape === 'image' && node.image) {
      const imageRelId = imageRelMap[node.id];
      if (imageRelId) {
        paragraph += `
    <w:p>
      <w:r>
        <w:drawing>
          <wp:inline xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing">
            <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
              <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
                <pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
                  <pic:nvPicPr>
                    <pic:cNvPr id="0" name="Picture ${node.id}"/>
                    <pic:cNvPicPr/>
                  </pic:nvPicPr>
                  <pic:blipFill>
                    <a:blip r:embed="${imageRelId}"/>
                    <a:stretch>
                      <a:fillRect/>
                    </a:stretch>
                  </pic:blipFill>
                  <pic:spPr>
                    <a:xfrm>
                      <a:off x="0" y="0"/>
                      <a:ext cx="990000" cy="792000"/>
                    </a:xfrm>
                    <a:prstGeom prst="rect">
                      <a:avLst/>
                    </a:prstGeom>
                  </pic:spPr>
                </pic:pic>
              </a:graphicData>
            </a:graphic>
          </wp:inline>
        </w:drawing>
      </w:r>
    </w:p>`;
      }
    }

    // 递归处理子节点
    if (tree[node.id] && tree[node.id].children.length > 0) {
      tree[node.id].children.forEach(child => {
        paragraph += generateParagraph(child, level + 1, tree);
      });
    }

    return paragraph;
  }

  // 辅助函数：转义XML特殊字符
  function escapeXML(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&apos;'
    };
    return text.replace(/[&<>"']/g, function (m) { return map[m]; });
  }

  // 辅助函数：收集所有包含图片的节点
  function gatherImages() {
    const images = {};
    nodes.forEach(node => {
      if (node.shape === 'image' && node.image) {
        images[node.id] = node.image; // node.image是DataURL
      }
    });
    return images;
  }

  // 辅助函数：将Base64转换为ArrayBuffer
  function base64ToArrayBuffer(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }

  // 辅助变量：图片关系映射
  let imageRelMap = {}; // nodeId -> relationship id

  // 辅助函数：生成 word/_rels/document.xml.rels
  function generateDocumentRels() {
    // 这里会在exportToWord函数中处理，因此此函数留空
    return `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>`;
  }

  // 辅助函数：生成 word/_rels/document.xml.rels 内容
  function generateDocumentRelsContent(imageRelMap) {
    let rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>`;

    let imageIndex = 2; // rId1已用于styles.xml
    for (const [nodeId, relId] of Object.entries(imageRelMap)) {
      rels += `
  <Relationship Id="${relId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/image${imageIndex}.${getImageExtension(images[nodeId])}"/>`;
      imageIndex++;
    }

    rels += `
</Relationships>`;
    return rels;
  }

  // 辅助函数：获取图片扩展名
  function getImageExtension(dataUrl) {
    const mime = dataUrl.split(';')[0].split('/')[1];
    return mime === 'jpeg' ? 'jpg' : mime; // 支持jpeg和png
  }

  // 辅助函数：生成 word/_rels/document.xml.rels (Initialize it empty)
  function generateDocumentRels() {
    return `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>`;
  }

  // 注意：由于word/_rels/document.xml.rels需要包含所有图片关系，因此在exportToWord函数内已经处理完成，此处无需额外内容。

  // ------------------- 导出为Word功能结束 -------------------
</script>
</body>

</html>