<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>趣味思维导图</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap');

    body, html {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Comic Neue', cursive;
      background-color: #FFF5E6;
    }

    #mindmap {
      width: 100%;
      height: 100%;
      background-color: #FFF5E6;
      background-image:
              radial-gradient(#FFD699 2px, transparent 2px),
              radial-gradient(#FFB366 2px, transparent 2px);
      background-size: 40px 40px;
      background-position: 0 0, 20px 20px;
    }

    .operation-instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 15px;
      font-size: 16px;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
      border: 3px solid #FF9933;
    }

    .instruction-item {
      margin-bottom: 10px;
    }

    .instruction-icon {
      display: inline-block;
      width: 30px;
      height: 30px;
      text-align: center;
      line-height: 30px;
      border-radius: 50%;
      margin-right: 10px;
      font-size: 18px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }

    .add-node-icon { background-color: #98FB98; color: #006400; }
    .add-child-icon { background-color: #87CEFA; color: #00008B; }
    .edit-node-icon { background-color: #FFA07A; color: #8B0000; }
    .delete-node-icon { background-color: #FFCC99; color: #8B4513; }

    #overview-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: #FF9933;
      border: none;
      outline: none;
      cursor: pointer;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.3s ease;
    }

    #overview-button:hover {
      transform: scale(1.1);
    }

    #overview-button:active {
      transform: scale(0.9);
    }

    #overview-button svg {
      width: 30px;
      height: 30px;
      fill: #8B4513;
    }

    @keyframes bounceIn {
      0% { transform: scale(0.1); opacity: 0; }
      60% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); }
    }

    .new-node {
      animation: bounceIn 0.6s;
    }
  </style>
</head>

<body>
<div class="operation-instructions">
  <div class="instruction-item">
    <span class="instruction-icon add-node-icon">+</span>
    <span>回车: 添加同级节点</span>
  </div>
  <div class="instruction-item">
    <span class="instruction-icon add-child-icon">⇥</span>
    <span>Tab: 添加子节点</span>
  </div>
  <div class="instruction-item">
    <span class="instruction-icon edit-node-icon">✎</span>
    <span>双击左键: 编辑节点</span>
  </div>
  <div class="instruction-item">
    <span class="instruction-icon delete-node-icon">✖</span>
    <span>Delete: 删除节点</span>
  </div>
</div>

<div id="mindmap"></div>

<button id="overview-button" title="重新调整视图">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3h-6zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3v6zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6h6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6v-6z"/>
  </svg>
</button>

<script>
  const nodes = new vis.DataSet([
    { id: 1, label: '主题', shape: 'box', font: { multi: true }, fixed: { x: true, y: true } }
  ]);

  const edges = new vis.DataSet([]);

  const container = document.getElementById('mindmap');
  const data = { nodes, edges };
  const options = {
    layout: { hierarchical: false },
    nodes: {
      shape: 'box',
      widthConstraint: { minimum: 100, maximum: 250 },
      font: { size: 20, multi: true, face: 'Comic Neue' },
      borderWidth: 3,
      shadow: true,
      color: {
        border: '#FF9933',
        background: '#FFFACD',
        highlight: { border: '#FF8000', background: '#FFE699' },
        hover: { border: '#FF8000', background: '#FFE699' }
      },
      shapeProperties: {
        borderRadius: 10
      },
      fixed: { x: true, y: true }
    },
    edges: {
      arrows: 'to',
      width: 3,
      color: '#FF9933',
      smooth: { type: 'cubicBezier', forceDirection: 'horizontal', roundness: 0.5 }
    },
    physics: { enabled: false },
    interaction: {
      dragNodes: true,
      dragView: true,
      zoomView: true,
      hover: true,
      selectable: true,
      selectConnectedEdges: false,
      multiselect: false,
      tooltipDelay: 300,
      hideEdgesOnDrag: false,
      hideNodesOnDrag: false
    },
    manipulation: { enabled: false }
  };

  const overviewButton = document.getElementById('overview-button');
  const network = new vis.Network(container, data, options);

  overviewButton.addEventListener('click', () => {
    network.fit({
      animation: {
        duration: 1000,
        easingFunction: 'easeInOutQuad'
      }
    });
  });

  let isEditingNode = false;

  network.on('doubleClick', function (params) {
    if (params.nodes.length === 1) {
      isEditingNode = true;
      const nodeId = params.nodes[0];
      const node = nodes.get(nodeId);
      const position = network.getPositions([nodeId])[nodeId];
      const domPos = network.canvasToDOM(position);

      const input = document.createElement('textarea');
      input.value = node.label;
      input.style.position = 'absolute';
      input.style.left = `${domPos.x - 140}px`;  // Increased width
      input.style.top = `${domPos.y - 35}px`;
      input.style.zIndex = 1000;
      input.style.width = '280px';  // Increased width
      input.style.height = '70px';  // Increased height
      input.style.fontSize = '22px';  // Increased font size
      input.style.fontFamily = 'Comic Neue, cursive';
      input.style.border = '3px solid #FF9933';
      input.style.borderRadius = '10px';
      input.style.padding = '10px';
      input.style.boxShadow = '0 0 15px rgba(0, 0, 0, 0.1)';
      input.style.backgroundColor = '#FFFACD';
      document.body.appendChild(input);
      input.focus();
      input.select();

      const handleInputChange = () => {
        const newLabel = input.value.trim();
        if (newLabel !== '') {
          nodes.update({ id: nodeId, label: newLabel });
        }
        if (document.body.contains(input)) {
          document.body.removeChild(input);
        }
        isEditingNode = false;
      };

      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleInputChange();
        }
        event.stopPropagation();
      });

      input.addEventListener('blur', handleInputChange);
    }
  });

  document.addEventListener('keydown', function (event) {
    const tag = event.target.tagName;
    if (isEditingNode || tag === 'INPUT' || tag === 'TEXTAREA') {
      return;
    }

    const selectedNodes = network.getSelectedNodes();
    if (selectedNodes.length === 1) {
      const selectedNode = selectedNodes[0];
      if (event.key === 'Enter') {
        event.preventDefault();
        const connectedEdges = network.getConnectedEdges(selectedNode);
        const parentEdge = edges.get(connectedEdges).find(edge => edge.to === selectedNode);
        const newNodeId = getNextNodeId();
        addNodeWithAnimation(newNodeId, `新节点${newNodeId}`, parentEdge ? parentEdge.from : selectedNode);
        network.selectNodes([newNodeId]);
      } else if (event.key === 'Tab') {
        event.preventDefault();
        const newNodeId = getNextNodeId();
        addNodeWithAnimation(newNodeId, `新节点${newNodeId}`, selectedNode);
        network.selectNodes([newNodeId]);
      } else if (event.key === 'Backspace' || event.key === 'Delete') {
        event.preventDefault();
        const previousNodeId = getPreviousNodeId(selectedNode);
        deleteNodeAndDescendants(selectedNode);
        setTimeout(() => {
          applyCustomLayout();
          if (previousNodeId) {
            network.selectNodes([previousNodeId]);
          }
        }, 100);
      }
    }
  });

  network.on("dragStart", function (params) {
    if (params.nodes.length === 1) {
      network.setOptions({ physics: false });
    }
  });

  network.on("dragEnd", function (params) {
    if (params.nodes.length === 1) {
      applyCustomLayout();
    }
  });

  nodes.on(['add', 'remove', 'update'], function (event, properties, senderId) {
    applyCustomLayout();
  });

  edges.on(['add', 'remove', 'update'], function (event, properties, senderId) {
    applyCustomLayout();
  });

  function getNextNodeId() {
    const existingIds = nodes.getIds();
    return Math.max(...existingIds) + 1;
  }

  function applyCustomLayout() {
    const tree = buildTree();
    const roots = findRoots(tree);
    const nodeSeparation = 150;
    const levelSeparation = 220;
    const startX = 50;
    const startY = container.clientHeight / 2;
    let currentY = startY;
    roots.forEach(root => {
      currentY = layoutNode(root, 0, startX, currentY, nodeSeparation, levelSeparation);
    });
    nodes.forEach(node => {
      nodes.update({ id: node.id, x: tree[node.id].x, y: tree[node.id].y });
    });
    network.fit();
  }

  function buildTree() {
    const tree = {};
    nodes.forEach(node => {
      tree[node.id] = { ...node, children: [] };
    });
    edges.forEach(edge => {
      if (tree[edge.from] && tree[edge.to]) {
        tree[edge.from].children.push(tree[edge.to]);
      }
    });
    return tree;
  }

  function findRoots(tree) {
    return Object.values(tree).filter(node => !edges.get().some(edge => edge.to === node.id));
  }

  function layoutNode(node, depth, xOffset, yOffset, nodeSeparation, levelSeparation) {
    node.x = xOffset + depth * levelSeparation;
    let numChildren = node.children.length;
    if (numChildren === 0) {
      node.y = yOffset;
      return yOffset + nodeSeparation;
    }
    let currentY = yOffset - (numChildren - 1) * nodeSeparation / 2;
    node.children.forEach(child => {
      currentY = layoutNode(child, depth + 1, xOffset, currentY, nodeSeparation, levelSeparation);
    });
    const firstChild = node.children[0];
    const lastChild = node.children[node.children.length - 1];
    node.y = (firstChild.y + lastChild.y) / 2;
    return currentY;
  }

  function deleteNodeAndDescendants(nodeId) {
    const descendants = getDescendants(nodeId);
    nodes.remove([nodeId, ...descendants]);
    edges.remove(edges.get().filter(edge => edge.from === nodeId || edge.to === nodeId || descendants.includes(edge.from) || descendants.includes(edge.to)));
  }

  function getDescendants(nodeId) {
    const descendants = [];
    const childEdges = edges.get().filter(edge => edge.from === nodeId);
    childEdges.forEach(edge => {
      descendants.push(edge.to);
      descendants.push(...getDescendants(edge.to));
    });
    return descendants;
  }

  function addNodeWithAnimation(newNodeId, label, parentNodeId) {
    const parentNode = nodes.get(parentNodeId);
    const parentPos = network.getPositions([parentNodeId])[parentNodeId];

    const initialX = parentPos.x + 50;
    const initialY = parentPos.y;

    nodes.add({
      id: newNodeId,
      label: label,
      shape: 'box',
      x: initialX,
      y: initialY,
      fixed: { x: false, y: false },
      color: { background: 'rgba(255, 255, 255, 0)', border: 'rgba(0, 0, 0, 0)' },
      font: { color: 'rgba(0, 0, 0, 0)' }
    });
    edges.add({ from: parentNodeId, to: newNodeId });

    setTimeout(() => {
      nodes.update({
        id: newNodeId,
        color: { background: '#FFFACD', border: '#FF9933' },
        font: { color: '#000000' },
        className: 'new-node'
      });
    }, 50);

    setTimeout(() => {
      nodes.update({
        id: newNodeId,
        className: ''
      });
    }, 650);

    setTimeout(applyCustomLayout, 100);
  }

  function getPreviousNodeId(currentNodeId) {
    const allNodes = nodes.get();
    const currentIndex = allNodes.findIndex(node => node.id === currentNodeId);
    if (currentIndex > 0) {
      return allNodes[currentIndex - 1].id;
    }
    return null;
  }

  applyCustomLayout();

  window.addEventListener('resize', applyCustomLayout);
</script>
</body>

</html>